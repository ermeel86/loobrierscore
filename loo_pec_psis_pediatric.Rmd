---
title: "Leave-One-Out Brier Score for survival models"
subtitle: "Using Pareto smoothed importance sampling"
author: "Eren M. El&ccedil;i"
date: "2018-11-18"
output: 
  html_document:
    df_print: paged

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(rstan);rstan_options(auto_write = TRUE)
library(loo)
library(survival)
library(tibble)
library(dplyr)
library(purrr)
library(bayesplot)
library(splines2)
library(pec)
library(cowplot)
cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
expose_stan_functions("~/Desktop/Stan/Loo_Pec/utils_surv.stan")
sm <- stan_model("~/Desktop/Stan/Loo_Pec/exponential_survival_simple_ppc_cond_loo.stan")
sm2 <- stan_model("~/Desktop/Stan/Loo_Pec/survival_parametric_baseline_hazard_simplex_loo.stan")
df <- read.delim("~/Desktop/Stan/Loo_Pec/pediatric.txt", sep=' ')
df <- mutate(df, time = t*12/365)
```


```{r inspect, echo=FALSE}
knitr::kable(
  head(df,5)
)
```

```{r, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE}
N <- nrow(df)
X <- as.matrix(as.integer(pull(df, race))-1)
is_censored <- pull(df,d)==0
times <- pull(df,time)
msk_censored <- is_censored == 1
N_censored <- sum(msk_censored)

time_range <- range(times)
time_min <- time_range[1]
time_max <- time_range[2] #time_range[2]
ninterior_knots <- 6
knots <- quantile(times[!msk_censored],head(tail(seq(0,1, length.out = ninterior_knots+2),-1),-1))

nknots <- length(knots)
mspline_degree<- 3
i_spline_basis_evals <- iSpline(times, knots=knots, degree=mspline_degree,
                                intercept=FALSE, Boundary.knots = c(0, time_max))
m_spline_basis_evals <- deriv(i_spline_basis_evals)
i_spline_basis_evals_censored <- i_spline_basis_evals[msk_censored,]
i_spline_basis_evals_uncensored <- i_spline_basis_evals[!msk_censored,]
m_spline_basis_evals_uncensored <- m_spline_basis_evals[!msk_censored,]
nbasis <- dim(i_spline_basis_evals_censored)[2]




stan_data <- list(N_uncensored=N-N_censored, 
                  N_censored=N_censored, 
                  X_censored=as.matrix(X[msk_censored,]),
                  X_uncensored=as.matrix(X[!msk_censored,]),
                  times_censored=times[msk_censored],
                  times_uncensored = times[!msk_censored],
                  NC=ncol(X),
                  m=nbasis,
                  m_spline_basis_evals_uncensored=m_spline_basis_evals_uncensored, 
                  i_spline_basis_evals_uncensored=i_spline_basis_evals_uncensored,
                  i_spline_basis_evals_censored=i_spline_basis_evals_censored
)

fit <- sampling(sm, data=stan_data, seed=42, chains=4, cores=2, iter=4000)
fit2 <- sampling(sm2, data=stan_data, seed=42, chains=4, cores=2, iter=4000)

post <- as.array(fit)
post2 <- as.array(fit2)
```


## Loo

```{r loo, echo=TRUE}
log_lik_1 <- extract_log_lik(fit, merge_chains = FALSE)
r_eff <- relative_eff(exp(log_lik_1)) 
loo_1 <- loo(log_lik_1, r_eff = r_eff, cores = 2)
print(loo_1)

log_lik_2 <- extract_log_lik(fit2, merge_chains = FALSE)
r_eff <- relative_eff(exp(log_lik_2)) 
loo_2 <- loo(log_lik_2, r_eff = r_eff, cores = 2)
print(loo_2)
comp <- compare(loo_1, loo_2)

print(comp)
```


# Posterior

## Constant

```{r, warning=FALSE, message=FALSE, error=FALSE}
broom::tidy(fit, conf.int=T) %>% filter(! term %in%  c(sprintf("times_uncensored_sampled[%d]", 1:stan_data$N_uncensored),
                                                       sprintf("log_lik[%d]", 1:N)
                                                       ))
```


## M-spline

```{r, warning=FALSE, message=FALSE, error=FALSE}
broom::tidy(fit2, conf.int=T) %>% filter(! term %in%  sprintf("log_lik[%d]", 1:N))
```


## Survival curves

### M-Spline


```{r surv_mspline,fig.align='center'}
intercepts <- as.vector(post2[,,"intercept"])
betas <- t(matrix(post2[,,sprintf("betas[%d]" ,1:ncol(X))], dim(post2)[1]*dim(post2)[2], ncol(X)))
gammas <- t(matrix(post2[,,sprintf("gammas[%d]", 1:nbasis)], dim(post2)[1]*dim(post2)[2], nbasis))

X_surv = as.matrix(c(0,1))
times_plot <- seq(0, time_max, length.out = 100)
i_spline_basis_evals <- iSpline(times_plot, knots=knots, degree=mspline_degree,
                                intercept=FALSE, Boundary.knots = c(0, time_max))

survs <- purrr::map(1:length(times_plot), ~rowMeans(surv_mspline_t(i_spline_basis_evals[.,], X_surv, gammas, intercepts, betas)))
surv_df <- dplyr::bind_rows(
  tibble(
  t=times_plot,
  race=F,
  surv=map_dbl(survs, ~.[[1]])
  ),
    tibble(
  t=times_plot,
  race=T,
  surv=map_dbl(survs, ~.[[2]])
  )) 
  ggplot(data=surv_df) + 
  geom_line(mapping=aes(x=t, y=surv, color=race))+
    geom_vline(xintercept = c(0,knots, time_max), alpha=.5, color='gray', linetype='dashed')+
  geom_rug(data=tibble(times=times[is_censored]), aes(x=times), col="green",alpha=0.5, size=1.25)+
  geom_rug(data=tibble(times=times[!is_censored]), aes(x=times), col="red",alpha=0.5, size=1.25)+
  scale_fill_manual(values=cbbPalette)+
  scale_colour_manual(values=cbbPalette)
  surv_df
```

### Constant


```{r, fig.align='center'}
intercepts <- as.vector(post[,,"intercept"])
betas <- t(matrix(post[,,sprintf("betas[%d]" ,1:ncol(X))], dim(post)[1]*dim(post)[2], ncol(X)))
X_surv = as.matrix(c(0,1))
times_plot <- seq(0, time_max, length.out = 100)
survs <- purrr::map(times_plot, ~rowMeans(surv_const_t(., X_surv, intercepts, betas)))
 surv_df <- dplyr::bind_rows(
  tibble(
  t=times_plot,
  race=F,
  surv=map_dbl(survs, ~.[[1]])
  ),
    tibble(
  t=times_plot,
  race=T,
  surv=map_dbl(survs, ~.[[2]])
  ) 
  )
  ggplot(data=surv_df) + 
  geom_line(mapping=aes(x=t, y=surv, color=race))+
    geom_vline(xintercept = c(0,knots, time_max), alpha=.5, color='gray', linetype='dashed')+
  geom_rug(data=tibble(times=times[is_censored]), aes(x=times), col="green",alpha=0.5, size=1.25)+
  geom_rug(data=tibble(times=times[!is_censored]), aes(x=times), col="red",alpha=0.5, size=1.25)+
  scale_fill_manual(values=cbbPalette)+
  scale_colour_manual(values=cbbPalette)
surv_df
```

# Brier Score (LOO-PSIS)

Denote by $\mathbf{T}_{-i}$ the $N-1$ dimensional vector of observed times (censored and uncensored) for all individuals, except for individual $i$. Write 
$S_i(t\vert \mathbf{T}_{-i})$ for the expected survival probability of patient $i$ at time $t$, where the expectation is with respect to the posterior over all latent model parameters $\theta$, given observations $\mathbf{T}_i$. 

Now, suppose $\{\theta_s\}_{s=1\dots S}$ is a (correlated) sequence of latent model parameters drawn from the posterior, given *all* observed times (including the one from individual $i$). We then can approximate $S_i(t\vert \mathbf{T}_{-i})$  as follows

$$
S_i(t\vert \mathbf{T}_{-i}) \approx \frac{\sum_{s=1}^S r_{s,i} S_i(t\vert \theta_s)}{\sum_{s=1}^S r_{s,i}}
$$

where $S_i(t\vert \theta_s)$ is the probability that individual $i$ survives beyond time $t$, given latent parameters $\theta_s$ and

$$
r_{s,i} \equiv \frac{1}{p(T_i\vert \theta_s)}
$$
Now, define

$$
\eta_{i,t} \equiv \left\{ 1_{\{T_i > t\}} - S_i(t\vert \mathbf{T}_{-i})\right\}^2
$$

Based on the residuals $\eta_{i}(t)$ we define, following Gerds et  al, the inverse probability of censoring weighted estimator $\Omega(t)$, defined as 

$$
\Omega(t)\equiv \frac{1}{N} \sum_{i=1}^N  w_i(t)\eta_{i}(t)^2 
$$

with 

$$
w_i(t) \equiv \frac{\mathbf{1}_{\{T_i \leq t\}} \delta_i}{G_i(T_i)} + \frac{\mathbf{1}_{\{T_i > t\}}}{G_i(t)}
$$

Here $\delta_i$ is the event indicator, i.e. $\delta_i = 1$ iff individual experienced the event and $0$ otherwise. Moreover $G_i(t)$ is the probability that the censoring time $C_i$ is exceeds $t$ for patient $i$. Note that for both the event and censoring survival functions we indicate a potential dependence on covariates by adding the index $i$. $G_i(t)$ can be obtained by fitting, for example, a Cox model to the data with reversed censoring indicators. By introducing a weighting based on $G_i$ we guarantee that the estimator's bias $\Omega(t)$ does not depent on the survival model (otherwise model comparison would be hard), see Gerds et al. It can be shown, see Gerds et al., that under weaks conditions, $\Omega(t)$ is a uniformly consistent estimator for the expected mean squared error in time (aka Brier score).

For both models, the constant and time dependent baseline hazard, we provide R functions `surv_const_loo` and `surv_mspline_loo` which can be used to calculate $S_i(t\vert \mathbf{T}_{-i})$ for all $i$ and required times $t$. This matrix $\{S_i(t\vert \mathbf{T}_{-i})\}_{i,t}$ can then be passed to the function `pec()` part of the  `pec` R Package, which calculates $\Omega(t)$ and provides ways to choose $G_i$, see the code below.



```{r, fig.align='center'}
intercepts <- as.vector(post[,,"intercept"])
betas <- t(matrix(post[,,sprintf("betas[%d]" ,1:ncol(X))], dim(post)[1]*dim(post)[2], ncol(X)))
X_surv = as.matrix(c(0,1))
times_pec <- seq(0, time_max, length.out = 100)
survs1 <- purrr::map(times_pec, ~rowMeans(surv_const_t(., X, intercepts, betas)))
survs1 <- do.call(cbind, survs1)

log_ratios <- -post[,,sprintf("log_lik[%d]",1:N)]
r_eff <- relative_eff(exp(log_ratios))
psis_result <- psis(log_ratios, r_eff = r_eff)
w <- matrix(weights(psis_result, log=FALSE), nrow=dim(X)[1], byrow = T) # TODO: check if this is correct reshaping!
survs_loo1 <- do.call(cbind, purrr::map(times_pec,~surv_loo(surv_const_t(., X, intercepts, betas), w)))
```



```{r, fig.align='center'}
intercepts <- as.vector(post2[,,"intercept"])
betas <- t(matrix(post2[,,sprintf("betas[%d]" ,1:ncol(X))], dim(post2)[1]*dim(post2)[2], ncol(X)))
gammas <- t(matrix(post2[,,sprintf("gammas[%d]", 1:nbasis)], dim(post2)[1]*dim(post2)[2], nbasis))
times_pec <- seq(0, time_max, length.out = 100)
i_spline_basis_evals <- iSpline(times_pec, knots=knots, degree=mspline_degree,
                                intercept=FALSE, Boundary.knots = c(0, time_max))

survs2 <- purrr::map(1:length(times_pec), ~rowMeans(surv_mspline_t(i_spline_basis_evals[.,], X, gammas,intercepts, betas)))
survs2 <- do.call(cbind, survs2)

log_ratios2 <- -post2[,,sprintf("log_lik[%d]",1:N)]
r_eff2 <- relative_eff(exp(log_ratios2))
psis_result2 <- psis(log_ratios2, r_eff = r_eff2)
w2<- matrix(weights(psis_result2, log=FALSE), nrow=dim(X)[1], byrow = T) # TODO: check if this is correct reshaping!


survs_loo2 <- do.call(cbind, purrr::map(1:length(times_pec),~surv_loo(surv_mspline_t(i_spline_basis_evals[.,], X, gammas, intercepts, betas), w2)))
```


```{r, fig.align='center'}
pec_rslt <- pec(list("MSpline-Loo"=survs_loo2, 
                     "Constant-Loo"=survs_loo1,
                     "MSpline"=survs2,
                     "Constant"=survs1
                     ), formula =Surv(time,d)~race , data=df, exact = F, times = times_pec,cens.model="marginal",
                splitMethod="none",
                B=0,
                verbose=TRUE)

df_pec <- tibble(time=pec_rslt$time, bs=pec_rslt$AppErr[["Constant-Loo"]], model="Constant-Loo") %>%
  bind_rows(tibble(time=pec_rslt$time, bs=pec_rslt$AppErr[["MSpline-Loo"]], model="MSpline-Loo")) %>%
  bind_rows(tibble(time=pec_rslt$time, bs=pec_rslt$AppErr[["Constant"]], model="Constant")) %>%
  bind_rows(tibble(time=pec_rslt$time, bs=pec_rslt$AppErr[["MSpline"]], model="MSpline")) %>%

  bind_rows(tibble(time=pec_rslt$time, bs=pec_rslt$AppErr[["Reference"]], model="Kaplan-Meier"))
ggplot(data=df_pec) +
  geom_vline(xintercept = c(0,knots, time_max), alpha=.5, color='gray', linetype='dashed')+
  geom_step(aes(x=time, y=bs, color=model))+
  geom_rug(data=tibble(times=times[is_censored]), aes(x=times), col="green",alpha=0.5, size=1.25)+
  geom_rug(data=tibble(times=times[!is_censored]), aes(x=times), col="red",alpha=0.5, size=1.25)+
  ylab("Brier Score")+
  xlab("Time")+  
  scale_fill_manual(values=cbbPalette)+
  scale_colour_manual(values=cbbPalette)

trsf_bs <- function(m) {
  dplyr::filter(df_pec, model==m) %>%
    dplyr::select(time, bs) %>%
    dplyr::rename(!!paste("bs",m,sep="_") := bs)
}

purrr::map(unique(df_pec$model),trsf_bs) %>% 
  purrr::reduce(left_join, by = "time")

```

### Constant only 

```{r, fig.align='center'}
pec_rslt <- pec(list("Constant-Loo"=survs_loo1, 
                     "Constant"=survs1
                     ), formula =Surv(time,d)~race , data=df, exact = F, times = times_pec,cens.model="marginal",
                splitMethod="none",
                B=0,
                verbose=TRUE)

df_pec <- tibble(time=pec_rslt$time, bs=pec_rslt$AppErr[["Constant-Loo"]], model="Constant-Loo") %>%
  bind_rows(tibble(time=pec_rslt$time, bs=pec_rslt$AppErr[["Constant"]], model="Constant"))

ggplot(data=df_pec) +
  geom_step(aes(x=time, y=bs, color=model))+
  geom_rug(data=tibble(times=times[is_censored]), aes(x=times), col="green",alpha=0.5, size=1.25)+
  geom_rug(data=tibble(times=times[!is_censored]), aes(x=times), col="red",alpha=0.5, size=1.25)+
  ylab("Brier Score")+
  xlab("Time")+  
  scale_fill_manual(values=cbbPalette)+
  scale_colour_manual(values=cbbPalette)
purrr::map(unique(df_pec$model),trsf_bs) %>% 
  purrr::reduce(left_join, by = "time")
```

### MSpline only 

```{r, fig.align='center'}
pec_rslt <- pec(list("MSpline-Loo"=survs_loo2, 
                     "MSpline"=survs2
                     ), formula =Surv(time,d)~race , data=df, exact = F, times = times_pec,cens.model="marginal",
                splitMethod="none",
                B=0,
                verbose=TRUE)

df_pec <- tibble(time=pec_rslt$time, bs=pec_rslt$AppErr[["MSpline-Loo"]], model="MSpline-Loo") %>%
  bind_rows(tibble(time=pec_rslt$time, bs=pec_rslt$AppErr[["MSpline"]], model="MSpline"))

ggplot(data=df_pec) +
  geom_vline(xintercept = c(0,knots, time_max), alpha=.5, color='gray', linetype='dashed')+
  geom_step(aes(x=time, y=bs, color=model))+
  geom_rug(data=tibble(times=times[is_censored]), aes(x=times), col="green",alpha=0.5, size=1.25)+
  geom_rug(data=tibble(times=times[!is_censored]), aes(x=times), col="red",alpha=0.5, size=1.25)+
  ylab("Brier Score")+
  xlab("Time")+  
  scale_fill_manual(values=cbbPalette)+
  scale_colour_manual(values=cbbPalette)

purrr::map(unique(df_pec$model),trsf_bs) %>% 
  purrr::reduce(left_join, by = "time")

```




